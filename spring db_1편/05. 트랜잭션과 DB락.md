## 트랜잭션 개념

- 하나의 거래를 안전하게 처리하도록 보장해주는 것
- 여러 작업을 진행하다가 문제가 생겼ㄷ을 경우 이전 상태로 롤백하기 위해 사용
- 한번 질의가 실행되면 질의가 모두 수행되거나 모두 수행되지 않는 작업수행의 논리적 단위
- 트랜잭션 커밋 - 작업이 마무리 됨
- 트랜잭션 롤백 - 작업을 취소하고 이전 상태로 돌림

## 트랜잭션 ACID

- 데이터베이스 내에서 일어나는 하나의 트랜잭션의 안전성을 보장하기 위해 필요한 성질
- 원자성, 일관성, 격리성, 지속성을 보장해 주는 것
- 원자성 - 트랜잭션 내에서 실행한 작업은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다
    - 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장
- 일관성 - 트랜잭션이 성공적으로 완료되면 일관적인 DB 상태를 유지한다
- 격리성 - 동시에 실행되는 트랜잭션이 서로 영향을 미치지 않도록 격리해야 한다
    - 동시에 같은 데이터를 수정하지 못하도록 한다
    - 격리성은 동시성과 관련있어 성능이슈 관련하여 격리수준을 선택해야 한다
- 지속성 - 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다
    - 중간에 시스템에 문제가 발생해도 데이터베이스 로그를 사용하여 성공한 트랜잭션 내용을 복구 해야 한다
    - 

## 트랜잭션과 격리 수준

- 트랜잭션의 원자성, 일관성 , 지속성을 보장한다
- 격리성을 보장하려면 트랜잭션을 순서대로 실행해야 한다
- 트랜잭션의 동시 처리 성능이 매우 나빠지는 단점이 있다

## 데이터베이스 연결 구조와 세션

![데이터베이스에 연결하는 과정과 세션](https://user-images.githubusercontent.com/42866800/166472759-3c14f541-15fe-44ae-ad33-9ce162898e3e.png)

1. 웹 애플리케이션 서버나 DB 접근 툴을 사용하여 데이터베이스 서버에 접근한다
2. 클라이언트는 데이터베이스 서버에 연결을 요청하고 커넥션을 맺게 된다
3. 데이터베이스 서버는 내부에 세션이 있는데 커넥션을 통해 들어온 요청은 세션을 통해 실행되게 된다
    1. 개발자가 클라이언트를 통해 SQL을 전달하면 현재 커넥션에 연결된 세션이 SQL을 실행한다
    2. 세션은 트랜잭션을 시작하고 커밋 또는 롤백을 통해 트랜잭션을 종료한다
    3. 사용자가 커넥션을 닫거나 DBA가 세션을 강제로 종료하면 세션은 종료된다

![커넥션 풀에서 10개의 커넥션을 생성하면 세션도 10개 만들어 진다](https://user-images.githubusercontent.com/42866800/166473010-24553f60-348f-45a4-8894-32c657bb06a5.png)

- 커넥션 풀에 10개의 커넥션을 생성하면 세션도 10개가 만들어 진다

## 자동 커밋 , 수동 커밋

- 자동 커밋
    
    ```sql
    set autocommit true; 
    ```
    
    - 각 쿼리 실행 직후 자동으로 커밋을 호출한다
    - 커밋이나 롤백을 직접 호출하지 않아도 되는 편리함이 있다
    - 쿼리를 실행할 때마다 자동으로 커밋이 되버리기 때문에 트랜잭션 기능을 제대로 사용할 수 없다
    - 쿼리 실행시 default가 autocommit true이다
    
- 수동 커밋
    
    ```sql
    set autocommit false;
    ```
    
    - 수동 커밋으로 설정해 놓는것을 트랜잭션을 시작한다고 표현한다
    - 수동 커밋을 설정한후 commit 또는 rollback을 호출해 줘야 한다
    - 수동 커밋 모드나 자동 커밋 모드는 한번 설정하면 해당 세션에서 계속 유지된다
    - 중간에 변경 가능하다

## 커밋과 롤백

### 트랜잭션 DB 예제 - 계좌이체

```java
drop table member if exists;
create table member (
      member_id varchar(10),
     money integer not null default 0,
     primary key (member_id)
);

set autocommit true;
insert into member(member_id, money) values('data1', 10000);
insert into member(member_id, money) values('data2', 10000);

select * from member;

// 트랜잭션 시작
set autocommit false; // 수동 커밋 모드

insert into member(member_id, money) values('newId1', 10000);
insert into member(member_id, money) values('newId2', 10000);

// 커밋 전이므로 세션1에서만 디비에 insert된 데이터를 볼 수 있다
select * from member;

// 세션1에서 커밋 진행
commit;
select * from member;

// 롤백 : 데이터베이스에 변경사항을 반영하지 않는다
// 데이터 초기화
set autocommit true;
delete from member;
insert into member(member_id, money) values('oldId', 10000);

// 트랜잭션 시작
set autocommit false; // 수동 커밋 모드

insert into member(member_id, money) values('newId1', 10000);
insert into member(member_id, money) values('newId2', 10000);

select * from member;

// 세션1이 롤백을 하는 경우
rollback;
// 데이터가 등록되기 전 상태로 돌아간다
select * from member;
```

```java
select * from member;

// 세션1이 아직 커밋을 하지 않았기 때문에 임시데이터를 볼 수 없다
select * from member;

//  세션1이 커밋을 한 후에 세션2가 조회 하는 경우
select * from member;
```

- 계좌이체 도중 문제가 발생했는데 커밋을 해버리는 경우


![트랜잭션 진행중 쿼리에 에러가 발생했는데 자동으로 커밋이 되어버리는 경우 발생하는 문제](https://user-images.githubusercontent.com/42866800/166473130-a2ca6165-8243-4896-b894-6bd0caea84bf.png)
ng)

- memberA가 memberB에게 2천원을 이체한다고 가정
- 세션1에서 트랜잭션이 시작되었다
- memberA의 돈에서 2천원이 차감되는 쿼리는 잘 수행이 되었다
- 그런데 memberB에 2천원이 증가되는 쿼리는 에러가 발생하여 제대로 수행되지 못했다
- 그런데 세션1 트랜잭션에서 강제 커밋을 시켰다
- 세션2가 테이블을 조회했을때 memberA의 금액은 2천원이 차감되었지만
- memberB의 금액은 2천원이 증가되지 않은 결과를 보게 된다
- 원하는데로 트랜잭션이 이뤄지지 못했다

```java

// 계좌이체 도중에 문제가 발생하는데 자동커밋으로 설정되 있는 경우

set autocommit true;

delete from member;

insert into member(member_id, money) values('memberA', 10000);
insert into member(member_id, money) values('memberB', 10000);

select * from member;

set autocommit false; // 트랜잭션 시작

update member set money = 10000 - 2000 where member_id = 'memberA';
update member set money = 10000 + 2000 where member_iddd = 'memberB'; // 쿼리 예외 발생

select * from member;
// memberA의 돈은 2천원 줄었지만 memberB의 돈은 2천원 증가되지 않았다

// 커밋을 하는 경우
// 세션2에서도 memberB의 돈이 2천원 증가되지 않은 값으로 보일것이다
commit;
// memberA의 돈만 2천원 줄어드는 심각한 문제가 발생하게 된다

```

- 계좌이체 도중 문제가 발생하여 rollback으로 데이터를 되돌리는 경우
- 중간에 쿼리에 문제가 발생하는 경우 커밋을 호출하면 안된다
- 롤백을 호출하여 데이터를 트랜잭션 시작 시점으로 원복시켜야 한다

![롤백하여 트랜잭션이 시작되기 이전상태로 데이터 원복시킨다](https://user-images.githubusercontent.com/42866800/166473323-ac9d82c1-ac05-4519-949c-a98e19325991.png)

```java
// 계좌이체 도중 문제가 발생하여 rollback으로 데이터를 되돌리는 경우

set autocommit true;

delete from member;

insert into member(member_id, money) values('memberA', 10000);
insert into member(member_id, money) values('memberB', 10000);

select * from member;

set autocommit false; // 트랜잭션 시작

update member set money = 10000 - 2000 where member_id = 'memberA';
update member set money = 10000 + 2000 where member_iddd = 'memberB'; // 쿼리 예외 발생

select * from member;

// rollback을 하여 트랜잭션을 시작하기 이전 상태로 되돌린다
// 트랜잭션을 시작하기 전단계로 데이터를 복구한다
rollback;

select * from member;
```

## DB 락

- 데이터의 일관성을 보장하기 위한 방법
- 특정 데이터에 대해 여러 트랜잭션이 무분별하게 동시에 접근하는 것을 막는 장치

- 세션1이 트랜잭션을 시작하고 데이터를 수정하는 동안 커밋을 하지 않았는데
- 세션2에서 동시에 같은 데이터를 수정하게 되면 여러가지 문제가 발생한다
- 트랜잭션의 원자성이 깨진다
- 또한 세션1이 중간에 롤백을 하게 되면 세션2는 잘못된 데이터를 수정하는 문제가 생긴다

```sql
set autocommit true;
delete from member;
insert into member(member_id, money) values ('memberA',10000);
```

### 해결책

- 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안 커밋이나 롤백전까지 다른 세션에서 해당 데이터를 수정할 수 없게 막아야 한다

- 1.

```sql
set autocommit false;
update member set money=500 where member_id = 'memberA';
```

- 세션1과 세션2가 동시에 동일한 row의 데이터를 수정하려고 한다

![세션1과 세션2가 데이터를 동시에 수정하는 문제를 락으로 어떻게 해결하는가](https://user-images.githubusercontent.com/42866800/166473541-1aec7a35-89dd-4ff2-99bb-e039b447078b.png)

- 2.

```sql
SET LOCK_TIMEOUT 60000;
set autocommit false;
update member set money=1000 where member_id = 'memberA';
```

- 세션1과 세션2가 동시에 같은 row에 접근했는데 세션1이 더 빨라서 세션1이 락을 획득했다

![세션1이 락을 획득한 경우](https://user-images.githubusercontent.com/42866800/166473586-e5562747-332b-4e6e-885d-df9dd85e5edf.png)
- 3.
- 세션1이 update 쿼리를 수행한다
- 세션2도 동시에 트랜잭션을 시작하여 락을 획득하려고 한다
- 그런데 락이 세션1에 있기 때문에 락을 획득할때 까지 대기해야 한다

![세션1이 update 작업을 수행한다](https://user-images.githubusercontent.com/42866800/166473626-6920d50c-6128-4ac5-b3d2-b8445c339074.png)
- 4.

```sql
commit;
```

- 세션1이 작업을 끝내고 커밋을 한다
- 락이 반납된다

![세션1이 커밋을 수행하고 락을 반납한다](https://user-images.githubusercontent.com/42866800/166473679-61ace3c2-d874-4e31-9aad-939ab3f64e8f.png)

- 5.

```sql
update member set money=1000 where member_id = 'memberA';
```

- 대기하고 있던 세견2가 락을 획득한다
- 세션2가 진행하려고 했던 update 쿼리가 수행된다

![락을 획득하기 위해 대기하던 세션2가 락을 획득한다](https://user-images.githubusercontent.com/42866800/166473740-7ef818d9-0ebf-46d9-bd86-36efc889a227.png)
- 6.

```sql
commit;
```

- 세션2가 작업을 완료하여 커밋을 한다
- 락이 반납된다


![세션2가 update 쿼리를 수행하고 커밋 한후 락을 반납한다](https://user-images.githubusercontent.com/42866800/166473888-88f2513c-d322-42a1-a7a1-90b3456ef549.png)

### 락 타임아웃

- 세션2가 락을 획득하기 위해 락 타임아웃 시간을 설정한다
- 설정된 시간안에 락을 획득하지 못하게 되면 락 타임아웃 에러가 발생하게 된다

```sql
Timeout trying to lock table {0}; SQL statement:
update member set money=10000 - 2000 where member_id = 'memberA' [50200-200]
HYT00/50200
```

## DB락 - 조회

- 데이터를 조회할 때도 락을 획득하고 싶은 경우
- 예) 데이터를 조회해서 데이터를 변경하는 중요한 작업을 진행하고 있는 경우 다른 세션이 이전 데이터를 조회해서 수정하는 경우 데이터 문제가 발생하는 상황에서 사용가능
- `select for update` 구문을 사용한다
- 세션1이 조회 시점에 락을 가져가 버리기 때문에 다른 세션에서 해당 데이터를 변경할 수 없다

```sql
set autocommit true;
delete from member;
insert into member(member_id, money) values ('memberA',10000);
```

- 세션1이 트랜잭션을 시작한다
- 조회를 하며너 동시에 선택한 로우의 락이 획득된다
- 세션1은 트랜잭션이 종료될 때까지 선택한 로우에 대한 락을 보유한다

```sql
set autocommit false;
select * from member where member_id='memberA' for update;
```

- 세션2도 데이터를 변경하고 싶지만 세션1이 락을 획득했기 떄문에 세션2는 대기해야 한다
![세션2도 데이터 변경을 위해 트랜잭션을 시작하지만 락이 없어 대기해야 한다](https://user-images.githubusercontent.com/42866800/166473900-312930a6-7ce8-4948-a505-0f2c8e94ca43.png)

```sql
set autocommit false;
update member set money=500 where member_id = 'memberA';
```

- 세션1이 작업을 마무리하고 커밋한다
- 락이 반납된다

```sql
commit;
```

- 세션2가 락을 획득하여 update 작업 진행후 커밋하면 락이 반납된다

```sql
commit;
```

## 트랜잭션 예제1

- 드라이버매니저를 사용하여 웹 애플리케이션과 디비 서버를 커넥션을 맺어준다

```java
@BeforeEach
void before() {
    DriverManagerDataSource dataSource = new DriverManagerDataSource(URL, USERNAME , PASSWORD );
    memberRepository = new MemberRepositoryV1(dataSource);
    memberService = new MemberServiceV1(memberRepository);
}
```

- Member 객체를 생성한다
- fromId 에서 toId 로 money만큼 돈을 이체한다
- fromId의 잔액은 money 만큼 차감된다
- toId의 잔액은 money 만큼 증가된다
- toId의 id가 ex인 경우 예외를 발생시킨다

```java
public void accountTransfer(String fromId, String toId, int money) throws SQLException {
    Member fromMember = memberRepositoryV1.findById(fromId);
    Member toMember = memberRepositoryV1.findById(toId);

    memberRepositoryV1.update(fromId, fromMember.getMoney() - money);
    validation(toMember);
    memberRepositoryV1.update(toId, toMember.getMoney() + money);
}
```

```java
private void validation(Member toMember) {
    if (toMember.getMemberId().equals("ex")) {
        throw new IllegalStateException("이체중 예외 발생");
    }
}
```

- 테스트 - 정상적으로 이체가 완료되는 경우
- MEMBER_A 객체와 MEMBER_B 객체를 생성한다
- 각각 금액은 만원을 갖고 있다
- 각 객체를 데이터베이스에 저장한다

- memberService에 선언된 accountTransfer 메서드를 호출하여 MEMBER_A가 MEMBER_B로 money만큼의 금액을 이체한다
- MEMBER_A의 경우 money만큼 차감된 금액을 데이터베이스에 업데이트 시킨다
- 이체를 받는 Member 객체의 이름이 ex인 경우 예외를 발생시킨다
- MEMBER_B의 경우 money 만큼 증가된 금액을 데이터베이스에 업데이트 시킨다

- 이체가 잘되었는지 검증
- member 객체의 memberId값을 사용하여 데이터베이스에서 조회해 온다
- memberA의 잔액이 이체한 money 금액만큼 차감되었는지 검사
- memberB의 잔액이 이체받은 money 금액만큼 증가되었는지 검사

```java
@Test
@DisplayName("정상 이체")
void accountTransfer() throws SQLException {
    // given
    Member memberA = new Member(MEMBER_A, 10000);
    Member memberB = new Member(MEMBER_B, 10000);
    memberRepository.save(memberA);
    memberRepository.save(memberB);

    // when
    memberService.accountTransfer(memberA.getMemberId(), memberB.getMemberId(), 2000);

    // then
    Member findMemberA = memberRepository.findById(memberA.getMemberId());
    Member findMemberB = memberRepository.findById(memberB.getMemberId());

    assertThat(findMemberA.getMoney()).isEqualTo(8000);
    assertThat(findMemberB.getMoney()).isEqualTo(12000);
}
```

- 테스트2 - 이체중 예외가 발생하는 경우
- MemberA가 MemberEX에게 이체하는 경우 예외가 발생한다
- 왜?
- `accountTransfer` 메서드에서 이체 받는 사람의 id를 검증할때 id가 ex인 경우 예외를 발생시키도록 설계했기 때문이다

```java
private void validation(Member toMember) {
    if (toMember.getMemberId().equals("ex")) {
        throw new IllegalStateException("이체중 예외 발생");
    }
}
```

- 예외가 발생함으로써 MemberA의 잔액만 money만큼 차감된다
- 왜?
- 예외가 발생하기 전에 MemberA의 잔액을 money 만큼 차감시킨후 데이터베이스에 update 쿼리를 실행시키기 때문이다

```java
memberRepositoryV1.update(fromId, fromMember.getMoney() - money);
validation(toMember);
memberRepositoryV1.update(toId, toMember.getMoney() + money);
```

- MemberEX의 경우 validation 메서드에 의해 id가 ex이므로 예외가 발생된다
- 즉 , udpate 쿼리가 실행되기 전에 예외가 먼저 발생되므로 MemberEX의 잔액은 그대로 유지되게 된다
- 따라서 검증할 때
- MemberA의 잔액은 트랜잭션이 롤백되어 기존 MemberA가 갖고 있던 잔액과 같은지 검증
- MemberEX의 잔액은 값이 그대로 유지되었는지 검증한다

```java
@Test
@DisplayName("이체중 예외가 발생함")
void accountTransferEx() throws SQLException {
    // given
    Member memberA = new Member(MEMBER_A, 10000);
    Member memberEX = new Member(MEBMER_EX, 10000);
    memberRepository.save(memberA);
    memberRepository.save(memberEX);

    // when
    assertThatThrownBy(() -> memberService.accountTransfer(
            memberA.getMemberId(), memberEX.getMemberId(), 2000))
            .isInstanceOf(IllegalStateException.class);

    // then
    Member findMemberA = memberRepository.findById(memberA.getMemberId());
    Member findMemberB = memberRepository.findById(memberEX.getMemberId());
    assertThat(findMemberA.getMoney()).isEqualTo(8000);
    assertThat(findMemberB.getMoney()).isEqualTo(10000);
}
```

참고 - 

[https://mangkyu.tistory.com/154](https://mangkyu.tistory.com/154)

[https://victorydntmd.tistory.com/129](https://victorydntmd.tistory.com/129)

[https://hanamon.kr/데이터베이스-트랜잭션의-acid-성질/](https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/)

[https://covenant.tistory.com/85](https://covenant.tistory.com/85)

[https://jordy-torvalds.tistory.com/121](https://jordy-torvalds.tistory.com/121)