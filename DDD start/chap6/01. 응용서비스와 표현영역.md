# 표현 영역과 응용 영역
## 개요

- 도메인이 제 기능을 수행하려면 사용자와 도메인을 연결해 주는 매개체가 필요하다
- 응용 영역과 표현 영역이 사용자와 도메인을 연결해 주는 매개체 역할을 한다
- 표현영역
- 사용자의 요청을 해석한다
- 요청을 받은 표현 영역은 URL , 요청 파라미터 , 쿠키 , 헤더 등을 사용하여 사용자가 어떤 기능을 실행하고 싶어 하는 지 판별하고 기능을 제공하는 응용 서비스를 실행한다

- 응용 서비스
- 실제 사용자가 원하는 기능을 제공한다
- 기능을 실행하는데 필요한 입력값을 메서드 파라미터로 전달받고 실행 결과를 리턴한다

<aside>
📌 응용 서비스의 메서닥 요구하는 파라미터와 표현 영역이 사용자로 부터 전달받은 데이터는 형식이 일치하지 않는다
표현 영역은 응용 서비스가 요구하는 형식으로 사용자 요청을 변환한다

</aside>

- 응용 서비스를 실행 한 뒤 표현 영역은 실행 결과를 사용자에게 알맞은 형식으로 응답해 준다
- 웹 브라우저인 경우 실행 결과를 HTML 형식으로 전송해 준다
- REST 클라이언트라면 JSON이나 XML 같은 형식으로 응답해 준다

## 응용 서비스의 역할

- 응용 서비스는 사용자가 요청한 기능을 실행한다
- 사용자의 요청을 처리하기 위해 리포지터리로부터 도메인 객체를 구하고
- 도메인 객체를 사용한다
- 응용 서비스의 주요 역할은 도메인 객체를 사용하여 자용자의 요청을 처리한다
- 사용자 입장에서 보았을때 응용 서비스는 돔인 영역과 표현 영역을 연결해 주는 파시드 역할을 한다

- 응용 서비스가 도메인 로직을 구현하는 경우
- 코드에 안좋은 영향을 준다
- 응용 서비스는 도메인의 상태 변경을 트랜잭션으로 처리한다
- 

### 도메인 로직 넣지 않기

- 도메인 로직은 도메인 영역에 위치하고 응용 서비스는 도메인 로직을 구현하지 않는다
- 도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생한다
- 코드의 응집성이 떨어진다
- 도메인 로직을 파악하기 위해 여려 영역을 분석해야 한다
- 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다

<aside>
📌 도메인 로직을 도메인 영역에 모아 클래스 응집도를 높여야 한다

</aside>

## 응용 서비스의 구현

### 응용 서비스의 크기

- 응용 서비스는 보통 다음의 두가지 방법중 한가지 방식으로 구현한다
- 한 응용 서비스 클래스에 도메인의 모든 기능 구현하기
- 각 기능에서 동일한 로직을 위한 코드 중복을 제거할 수 있다
- 한 서비스 클래스의 크기가 커진다
- 연관성이 적은 코드가 한 클래스에 함께 위치하게 될 가능성이 높다
- 관련없는 코드가 뒤섞여 코드를 이해하는데 방해가 될 수 있다
- 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기
- 한 응용 서비스 클래스에 2 ~ 3 개의 기능을 구현한다
- 클래스 개수는 많아지지만 한 클래스에 관련 기능을 모두 구현하는 것과 비교해서 코드 품질을 일정 수준으로 유지할 수 있다
- 각 클래스 별로 필요한 의존 객체만 포함하므로 다른 기능을 구현한 코드에 영향을 받지 않는다
- 각 기능마다 동리한 로직을 구현할 경우 여러 클래스에 중복해서 동일한 코드를 구현할 가능성이 있다
- 별로 클래스에 로직을 구현하여 코드가 중복되는 것을 방지할 수 있다

```java
public class MemberService {
    
    private MemberRepository memberRepository;
    
    public void join(MemberJoinRequest request) {...}
    public void changePassword(String memberId, String currentPw, String newPw) {...}
    public void initializePassword(String memberId) {...}
    public void leave(String memberId, String curPw) {...}
    
}
```

<aside>
📌 한 도메인과 관련되어 구분되는 기능을 별도의 서비스 클래스로 구현한다

</aside>

```java
public class MemberService {
    private MemberRepository memberRepository;
    private Notifier notifier;
    
    public void changePassword(String memberid, String currentPw, String newPw) {
         Member member = findExitsingMember(memberId);
         member.changePassword(currentPw, newPw);
    }
    
    public void initializePassword(String password) {
        Member member = findExistingMember(memberId);
        String newPassword = member.initializePassword();
        notifier.notifyNewPassword(member, newPassword);
    }
    
    public void leave(String memberId, String curPw) {
        Member member = findExistingMember(memberId);
        member.leave();
    }
    
    private Member findExistingMember(String memberId) {
        Member member = memberRepository.findById(memberId);
        if (member == null) {
            throw new NoMemberExcpetion(memberId);
        }
        return member;
    }
}
```

```java
public class ChangePasswordService {
    private MemberRepository memberRepository;
    
    public void changePassword(String memberId, String curPw, String newPw) {
         Membmer member = memberRepository.findById(memberId);
         if (member == null) {
             throw new NoMemberException(memberId);
         }
         member.changePassword(curPw, newPw);
    }
}
```

```java
public final class MemberServiceHelper {
    public static Member findExistingMember(MemberRepository repo, String memberId) {
        Member member = memberRepository.findById(memberId);
        if (member == null) {
            throw new noMemberException(memberId);
        }
        return member;
    }
}
```

### 응용 서비스의 인터페이스와 클래스

- 인터페이스가 필요한 경우
- 구현 클래스가 여러개인 경우
- 구현 클래스가 다수 존재하거나 런타임에 구현 객체를 교체해야 할 경우 인터페이스를 유용하게 사용할 수 있다
- 응용 서비스는 런타임에 구현 클래스를 교체하는 경우가 드물다
- 한 응용 서비스의 구현 클래스가 두개인 경우도 드물다
- 인터페이스와 클래스를 따로 구현하면 소스 파일만 많아지고 구현 클래스에 대한 간접 참조가 증하하여 전체적인 구조가 복잡해 진다

```java
@RequestMapping(method = RequestMethod.POST)
public String submit(ChangePasswordRequest changePwdReq) {
    Authentication auth = SecurityContext.getAuthentication();
    changePwdReq.setMemberId(auth.getId());

    try {
        changePasswordService.changepassword(changePwdReq);        
        
    } catch (NoMemberException ex) {
        ...
    }    
}
```

<aside>
📌 인터페이스가 명확히 필요하기 전까지는 응용 서비스에 대한 인터페이스를 작성하는 것이 좋은 설계가 아니다

</aside>

- Mockito와 같은 테스트 도구는 클래스에 대해 테스트용 가짜 객체를 만들어 준다
- 응용 서비스에 대한 인터페이스가 없어도 표현 영역을 테스트 할 수 있다
- 결과적으로 응용 서비스에 대한 인터페이스 필요성을 약화 시킨다

### 메서드 파라미터와 값 리턴

- 응용 서비스가 제공하는 메서드는 도메인을 사용하여 사용자가 요구한 기능을 실행하는데 필요한 값을 파라미터를 통해 전달받아야 한다
- 필요한 각 값을 개별 파라미터로 전달받을 수도 있고
- 값 전달을 위한 별도 데이터 클래스를 만들어 전달받을 수도 있다
- 응용 서비스에 데이터로 전달할 요청 파라미터가 두 개 이상 존재하면 데이터 전달을 위한 별도 클래스를 사용하는 것이 바람직하다
- 응용 서비스에서 애그리거트 자체를 리턴 하면 코딩을 편할 수 있지만 도메인 로직 실행을 응용 서비스와 표현 영역 두곳에서 할 수 있게 된다
- 이는 기능 실행 로직을 응용 서비스와 표현영역에 분산시켜 코드의 응집도를 낮추는 원인이 된다

```java
public class ChangePasswrodService {
    public void changePassword(ChangePasswordRequest request) {
        Member member = findExistingMember(request.getMemberid());
        member.changePassword(request.getCurrentPassword(), request.getNewPassword());
    }
}

public class ChangePasswordRequest {
    private String memberId;
    private String curPw;
    private String newPw;
    
    ...
    // 생성자나 get 메서드
}
```

```java
public class OrderService {
    
    public OrderNo placeOrder(OrderRequest orderRequest) {
         OrderNo orderNo = orderRepository.nextId();
         Order order = createOrder(orderno, orderRequest);
         orderRepository.save(order);
         return orderNo;
    }
}
```

<aside>
📌 응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높일 수 있다

</aside>

### 표현 영역에 의존하지 않기

- 표현 영역과 관련된 타입을 응용 서비스에 파라미터로 전달하면 안된다
- 응용서비스만 단독으로 테스트 하기가 어려워 진다
- 표현영역의 구현이 변경되면 응용 서비스의 구현도 함께 변경해야 하는 문제가 생긴다
- 응용서비스가 표현 영역의 역할까지 대신하는 상황이 벌어질 수도 있다

### 트랜잭션 처리

- 프레임워크가 제공하는 트랜잭션 규칙을 따르면 트랜잭션을 시작하고 커밋하고 익셉션이 발생하면 롤백할 수 있다
- @Transactional 이 적용된 메서드에서 RuntimeException이 발생하면 트랜잭션을 롤백하고 그렇지 않으면 커밋한다

```java
public class ChangePasswrodService {
    
    @Transactional
    public void changePassword(ChangePasswordRequest request) {
        Member member = findExistingMember(request.getMemberId());
        member.changePassword(request.getCurrentPasswrod(), request.getNewPassword());
    }
}
```

### 도메인 이벤트 처리

- 응용 서비스의 역할 중 하나는 도메인 영역에서 발생시킨 이벤트를 처리하는 것이다
- 도메인 영역은 상태가 변경되면 이를 외부에 알리기 위해 이벤트를 발생시킬 수 있다

```java
public class Member {
    private Password passwrod;
    
    public void initializePassword() {
        String newPassword = generateRandomPassword();
        this.password = new Password(newPassword);
        Events.raise(new PasswordChangedEvent(this.id, password));
    }
}

public class InitPasswordService {
    
    
    public void initializePassword(String memberId) {
        Events.handle((PasswordChangedEvent evt) -> {
            evt.getId();
        });
        
        
        Member member = memberRepository.findById(memberId);
        checkMemberExists(member);
        member/initializePassword();
    }
    
    
    
}
```

- 도메인에서 이벤트를 발생시키면 이벤트를 받아서 처리하는 역할을 응용 서비스가 한다
- 응용 서비스는 이벤트를 받아서 이벤트에게 알맞은 후처리를 시킨다
- 암호 초기화의 경우 암호 초기화됨 이벤트가 발생하면 변경한 암호를 이메일로 발송하는 이벤트 핸들러를 등록할 수 있다
- 이벤트를 사용하면 코드가 복잡해 지는 대신 도메인 간 의존성이나 외부 시스템에 대한 의존을 낮춰준다
- 시스템을 확장하는데 이벤트가 핵심 역할을 수행하게 된다


## 표현영역

- 사용자가 시스템을 사용할 수 있는 화면을 제공하고 제어한다
- 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다
    - 화면을 보여주는데 필요한 데이터를 읽거나 도메인의 상태를 변경해야 할 떄 응용 서비스를 사용한다
    - 이 과정에서 표현영역은 사용자의 요청 데이터를 응용 서비스가 요구하는 형식으로 변환하고 응용 서비스의 결과를 사용자에게 응답할 수 있는 형식으로 변환한다
- 사용자의 세션을 관리한다
    - 사용자의 연결상태인 세션을 관리한다
    - 웹의 경우 쿠키나 서버 세션을 사용하여 사용자의 연결 상태를 관리한다
    - 세션 관리는 권한 검사와도 연결된다

```java
@RequestMapping(method = RequestMethod.POST)
public String changePassword(HttpServletRequest request, Errors errors) {
    String curPw = request.getParameter("curPw");
    String newPw = request.getParameter("newPw");
    String memberId = SecurityContext.getAuthentication().getId();
    ChangePasswordRequest chPwdReq = new ChangePasswordRequest(memberId, curPw, newPw);
    
    
  try {
    changePasswrodService.changePassword(chPwdReq);
    return successView;  
  } catch (BadPasswordException | NoMemberException ex) {
      errors.reject("idPasswordNoMatch");
      return formView;
  } 
}
```

- HTTP 요청 파라미터로 부터 자바 객체를 생성하는 기능을 지원한다
- 따라서 응용 서비스에 전달할 자바 객체를 쉽게 생성할 수 있다

```java
@RequestMapping(method = RequestMethod.POST)
public String changePassword(ChangePasswordRequest chPwdReq, Errors errors) {
    String memberId = SecurityContext.getAuthentication().getId();
    chPwdReq.setMemberId(memberId);
    
  try {
    changePasswrodService.changePassword(chPwdReq);
    return successView;  
  } catch (BadPasswordException | NoMemberException ex) {
      errors.reject("idPasswordNoMatch");
      return formView;
  } 
}
```

## 값 검증

- 표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있다
- 표현영역에서 검증하는 방법

```java
@GetMapping
public String join(JoinRequest joinRequest, Errors errors) {
    checkEmpty(joinRequest.getId(), "id", errors);
    checkEmpty(joinRequest.getName(), "name", errors);
    ...
    
    
    if (errors.hashErrors()) {
        return formView;
    }
    
    try {
        joinService.join(joinRequest);
        return successView;
    } catch (DuplicationException ex) {
        errors.rejectValue(ex.getPropertyName(), "duplicate");
        return formView;
    }
}

private void checkEmpty(String value, String property, Errors errors) {
    if (isEmpty(value)) {
        errors.rejectValue(property, "empty");
    }
}
```

- 응용 서비스에서 검증하는 방법

```java
public class JoinService {
    public void join(JoinRequest request, Errors errors) {
        new JoinRequestValidator().validate(joinRequest, errors);
        if (!errors.hasErrors()) checkDuplicateId(joinReq.getId(), errors)
        if (errors.hasErrors()) return;
    }
}
```

## 권한 검사

- 개발할 시스템 마다 권한의 복잡도가 달라진다
- 단순한 시스템은 인증 여부만 검사하면 되는데 , 어떤 시스템은 관리자인지 여부에 따라 사용할 수 있는 기능이 달라지기도 한다
- 표현영역 , 응용 서비스 영역 , 도메인 영역에서 권한 검사를 수행할 수 있다
- 서블릿 필터를 통해 사용자의 인증 정보를 생성하고 인증 여부를 검사한다
- 스프링 시큐리티는 필터를 사용해서 인증 정보를 생성하고 웹 접근을 제어하는 기능을 제공한다
- AOP를 활용하여 애노테이션으로 서비스 메서드에 대한 권한검사를 할 수 있는 기능을 제공한다

```java
public class BlockMemberService {
    private MemberRepository memberRepository;
    
    @PreAuthorize("hasRole('ADMIN')")
    public void block(String memberId) {
        Member member = memberRepository.findById(memberId);
        if (member == null) {
            throw new NoMemberException();
        }
        member.block();
    }
    
    
}
```

## 개별 도메인 단위로 권한 검사를 해야 하는 경우

- 게시글 삭제는 본인 또는 관리자 역할을 가진 사용자만 할 수 있다고 가정

```java
public class DeleteArticleService {
    public void delete(String userId, Long articleId) {
        Article article = articleRepository.findById(articleId);
        checkArticleExistence(article);
        permissionService.checkDeletePermission(userId, article);
        article.markDeleted();
    }
}
```

## 조회 전용 기능과 응용 서비스

- 서비스에서 수행하는 추가적인 로직이 없고 조회 전용 기능인 경우 굳이 서비스를 만들 필요가 없다
- 표현 영역에서 바로 조회 전용 기능을 사용해도 된다

```java
public class OrderController {
    private OrderViewDao orderViewDao;
    
    @RequestMapping("/myorders");
    public String list(ModelMap model) {
        String ordererId = SecurityContext.getAuthentication().getId();
        List<OrderView> orders = orderViewDao.selectByOrderer(ordererId);
        model.addAttribute("orders", orders);
        return "order/list";
    }
}
```








## 결론

- 사용자와 도메인을 연결해주는 매개체가 표현영역과 응용영역 이다
- 응용 서비스가 도메인 로직을 구현하면 코드 품질에 않좋다
- 도메인 데이터와 데이터를 조작하는 도메인 로직이 한 영역에 위치하지 않고 서로 다른 영역에 위치하면 도메인 로직을 파악하기 위해 여려 영역을 분석해야 한다
- 도메인 과 관련된 기능별로 서비스 클래스를 구분하여 구현한다
- 각 클래스 별로 필요한 의존객체만 포함하므로 다른 기능을 구현한 코드에 영향을 주지 않는다

## 블로그 프로젝트에 반영할 수 있는 방법

- 도메인 기능 별로 서비스 클래스를 구분한다
- 동일한 책임을 갖는 도메인의 경우 추상화 하여 내부 구현을 인터페이스 뒤로 숨긴다
- 표현 영역에서 응용 서비스에 메서드로 데이터를 전달해 주는 경우 데이터 전달을 위한 별도 클래스를 만들어 전달해 준다
- 응용 서비스 영역에서 트랜잭션을 사용하여 예외가 발생했을때 트랜잭션을 롤백하고 그렇지 않으면 커밋한다
- 표현 영역에서 사용되어야 할 파라미터를 응용서비스 영역에서 사용하지 않는다