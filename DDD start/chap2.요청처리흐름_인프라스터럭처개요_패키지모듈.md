# 요청 처리 흐름

## 요청 처리 흐름

- 사용자가 애플리케이션에 기능 실행을 요청하면 표현 영역이 요청을 받는다
- spring mvc를 사용하여 웹 애플리케이션을 구현했다면 컨트롤러가 사용자의 요청을 받아 처리하게 된다
- `표현영역` - 사용자가 전송한 데이터 형식이 올바른지 검사하고 문제가 없다면 데이터를 이용하여 응용 서비스세 기능 실행을 위임한다
- 표현영역은 사용자가 전송한 데이터를 응용 서비스가 요구하는 형식으로 변환하여 전달한다
- `응용 서비스` - 도메인 모델을 사용하여 기능을 구현한다
- 기능 구현에 필요한 도메인 객체를 리포지터리에서 가져와 실행한다
- 신규 도메인 객체를 생성하여 리포지터리에 저장한다

- 얘매 하거나 얘매 취소와 같은 기능을 제공하는 응용 서비스는 도메인의 상태를 변경하므로 변경 상태가 물리 저장소에 올바르게 반영되도록 트랜잭션을 관리해야 한다
- 스프링 프레임워크를 사용하면 스프링이 제공하는 트랜잭션 관리 기능을 사용하여 트랜잭션을 처리할수 있다
```
public class CancelOrderService {
    private OrderRepository orderRepository
    
    public void cancel(OrderNumber number) {
        Order order = orderRepository.findByNumber(number);
        if (order == null) {
            throw new NoOrderException(number);
        }
        order.cancel();
    }
}

```


# 인프라스트럭처 개요

## 인프라스트럭처 개요

- 표현 영역 , 응용 영역 , 도메인 영역을 지원한다
- DIP에서 언급한것 처럼 도메인 영역과 응용 영역에서 인프라스트럭처의 기능을 직접 사용하는 것 보다 두 영역에서 정의한 이터페이스를 인프라스트럭처 영역에서 구현하는 것이 시스템을 더 유연하고 테스트하기 쉽게 만들어 준다

- 무조건 인프라스트럭처에 대한 의존을 없애는 것이 좋은 것은 아니다
- 스프링을 사용할 경우 응용 서비스는 트랜잭션 처리를 위해 스프링이 제공하는 @Transactional을 사용하는 것이 편리하다
- 영속성 처리를 위해 JPA를 사용하는 경우 @Entity 나 @Table과 같은 JPA 전용 어노테이션을 도메인 모델 클래스에 사용하는 것이
- XML 매핑 설정을 사용하는 것 보다 편리하다
```
@Entity
@Table(name = "TBL_ORDER")
public class Order {
    ...
}
```



# 모듈 구성

## 모듈 구성

- 아키텍처의 각 영역은 별도 패키지에 위치한다
- 영역별로 모듈이 위치할 패키지를 구성할 수 있다
- 예) com.myshop
- 도메인이 크면 하위 도메인으로 나누고 각 하위 도메인마다 별도 패키지를 구성한다

- domain 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성한다
- 예) 카탈로그 하위 도메인을 위한 도메인은 상품 애그리거트와 카테고리 애그리거트로 구성된다고 할 경우 domain을 두개의 하위 패키지로 구성할 수 있다