## 선점 잠금

- 애그리거트를 구한 스레드가 애그리거트 사용이 끝날때 까지 다른 스레드가 해당 애그리거트를 수정하는 것을 막는다
- 한 스레드가 애그리거트를 수정하는 동안 다른 스레드가 수정할 수 없다
- 동시에 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소 할 수 있다
- 선점 잠금은 DBMS가 제공하는 행 단위 잠금을 사용해서 구현한다
- 다수의 DBMS가 for update 쿼리를 사용해서 특정 레코드에 한 사용자만 접근할 수 있는 잠금 장치를 제공한다

### 선점잠금과 교착상태

- 선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교착 상태가 발생하지 않도록 주의해야 한다
- 사용자 수가 많을 때 교착 상태가 발생할 가능성이 높다
- 사용자 수가 많아지면 교착 상태에 빠지는 스레드가 더 빠르게 증가하게 되기 때문이다
- 잠금을 구할때 최대 대기 시간을 지정해야 한다
- 지정한 시간 이내에 잡금을 구하지 못하면 익셉션을 발생시킨다

<aside>
📌 DBMS에 대해 JPA가 어떤 식으로 대기 시간을 처리하는지 확인해야 한다

</aside>

## 비선점 잠금

- 잠금을 해서 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인한다
- 기능을 실행하는 과정에서 애그리거트 데이터가 변경되면 JPA는 트랜잭션 종료 시점에 비선점 잠금을 위한 쿼리를 실행한다
- 비선점 잠금을 위한 쿼리를 실행할 때 쿼리 실행 결과로 수정된 행의 개수가 0이면 이미 누군가 앞서 데이터를 수정한 것이다
- 이는 트랜잭션이 충돌한 것이므로 태랜잭션 종료 시점에 익셉션이 발생한다
- 애그리거트를 수정할 때 사용자가 전송한 버전과 애그리거트 버전이 동일한 경우 수정 기능을 수행하도록 하여 트랜잭션 충돌 문제를 해소한다


### 강제 버전 증가

- 연관된 엔티티의 값이 변경되어도 루트 엔티티 자체의 값은 증가되지 않는다
- 루트 엔티티의 버전 값을 갱신하지 않는다
- 하지만 비선점 잠금이 올바르게 동작하려면 애그리거트 내 어떤 구성요소의 상태가 변하면 루트 애그리거트의 버전 값을 증가시켜야 한다

### 오프라인 선점 잠금

- 여러 트랜잭션에 걸쳐 동시 변경을 막는다
- 첫번째 트랜잭션을 시작할 때 오프라인 잠금을 선점한다
- 마지막 트랜잭션에서 잠금을 해제한다
- 잠금을 해제하기 전까지 다른 사용자는 잠금을 구할 수 없다
- 오프라인 선점 방식은 잠금의 유효 시간을 가져야 한다
- 유효 시간이 지나면 자동으로 잠금을 해제해서 다른 사용자가 잠금을 일정 시간 후에 다시 구 할 수 있도록 해야 한다
- 오프라인 선점 잠금은 잠금 선점 시도 , 잠금 확인 , 잠금 해제 , 락 유효 시간 연장의 네가지 기능을 제공한다
- LockManager 인터페이스를 통해 해당 기능을 실행할 수 있다

- DB를 사용한 LockManager 구현
- MySQL을 사용하는 경우 잠금 정보를 저장할 테이블과 인덱스를 생성한다