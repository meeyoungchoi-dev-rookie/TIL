# 리포지터리와 애그리거트

## 애그리거트

- 복잡한 도메인을 상위 수준에서 조망할 수 있는 방법
- 관련된 객체를 하나의 군으로 묶어 준다

![쇼핑몰을 애그리거트로 모델링](https://user-images.githubusercontent.com/42866800/159904488-794d598a-e52d-43f6-bcc5-3cc39858957e.png)

- 애그리거트는 경계를 갖는다
    - 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다
    - 예)
    - 주문 애그리거트에서 회원의 정보를 변경할 수 없다
    - 또는 주문 애그리거트에서 상품의 정보를 변경할 수 없다

## 애그리거트 루트

- 애그리거트 전체를 관리할 주체
- 애그리거트의 루트 엔티티
- 애그리거트의 일관성이 깨지지 않도록 한다
- 애그리거트가 제공해야 할 도메인 기능을 구현
    - 애그리거트에 속해 있는 엔티티와 밸류를 사용하여 애그리거트가 구현해야 할 기능을 제공한다
    - 예)
    - 주문 애그리거트는 배송지 변경 , 상품 변경과 같은 기능을 제공
    - 애그리거트 루트가 해당 기능을 구현하여 메서드로 제공
    - 애그리거트에 속한 다른 객체가 애그리거트를 변경할 수 없다
- 애그리거트 내부를 숨겨 애그리거트 단위로 캡슐화 한다
    - 애그리거트 루트가 메서드를 통해 애그리거트의 상태 변경을 위임한다
- 트랜잭션 범위
    - 한 애그리거트에서 다른 애그리거트를 수정할 수 없다

## 리포지터리

- 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능 정의
- 완전한 애그리거트를 제공하지 않으면 필드나 값이 올바르지 않아 NULLPointerException 이 발생할 수 있다
- 리포지터리는 애그리거트 루트 단위로 존재한다
- 테이블 단위로 존재하면 안된다

## 리포지터리와 애그리거트

- 애그리거트는 한 개의 도메인 모델을 표현한다
- 리포지터리는 애그리거트 단위로 존재한다

![주문 애그리거트의 루트 엔티티 Order](https://user-images.githubusercontent.com/42866800/159904553-534d77cd-065f-4bcd-816f-26f3e89f9102.png)


- 예)
- Order와 OrderLine을 물리적으로 각각 별도의 DB 테이블에 저장한다고 해서 Order 와 OrderLine을 위한 리포지터리를 각각 만들지 않는다
- Order가 애그리거트 루트이고 OrderLine은 애그리거트에 속하는 구성요소 이므로 Order를 위한 리포지터리만 있으면 된다

### 애그리거트 사용

- 새로운 애그리거트를 사용하려면 저장소에서 애그리거트를 읽어야 한다
- `save` - 에그리거트 저장
- `findById` - ID로 에그리거트를 조회
- 리포지터리가 완전한 애그리거트를 제공하지 않으면 데이터 일관성이 깨지는 문제가 발생할 수 있다
- 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다
- RDBMS를 사용하는 경우 트랜잭션을 사용하여 애그리거트의 변경이 저장소에 반영되는 것을 보장할 수 있다
- MongoDB를 사용하면 한 개의 애그리거트를 한 개의 문서에 저장함으로써 한 애그리거트의 변경을 손실없이 저장할 수 있다

## ID를 사용한 애그리거트 참조

- 애그리거트도 다른 애그리거트를 참조한다
- 애그리거트간 참조한 필드를 통해 구현할 수 있다
- 

![애그리거트 루트에 대한 참조](https://user-images.githubusercontent.com/42866800/159904613-17cea2de-8725-44f5-adb3-ca95e7549f9c.png)

- 필드를 사용하여 다른 애그리거트를 직접 참조하면 편리하다
- 예)
- 주문 정보 조회 홤녀에서 회원 아이디를 사용하여 링크를 제공하는 경우
- Order에서 시작하여 회원아이디를 구할 수 있다

### 필드를 사용한 애그리거트 참조의 문제

- 편리함을 오용
    - 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다
    - 한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 한다
- 성능에 대한 고민
    - 즉시 로딩
    - 지연 로딩
- 확장
    - 사용자가 몰리는 경우 하위 도메인 별로 시스템을 분리
    - 가가 도메인 마다 다른 종류의 데이터베이스를 사용하기도 한다
    - 즉 , 애그리거트 루트를 참조하기 위해 단일 기술을 사용할 수 없게 된다

### ID를 사용하여 애그리거트 참조

- 애그리거트를 참조할 때 ID 참조를 사용한다

![아이디를 이용한 간접 참조](https://user-images.githubusercontent.com/42866800/159904663-1497f0d5-c29f-4d03-b529-3f9acad0fb0a.png)

- ID참조를 사용하면 한 애그리거트에 속한 객체들만 참조로 연결된다
- 복잡도를 낮춰준다
- 한 애그리거트에서 다른 애그리거트를 수저앟는 문제를 원천적으로 방지할 수 있다
- 외부 애그리거트를 직접 참조하지 않기 때문에 한 애그리거트에서 다른 애그리거트의 상태를 변경할 수 없다
- 

![쇼핑몰을 애그리거트로 모델링](https://user-images.githubusercontent.com/42866800/159904488-794d598a-e52d-43f6-bcc5-3cc39858957e.png)

- 예)
- 주문 애그리거트에서 회원 애그리거트를 직접 참조할 수 없다
- 외부 애그리거트의 상태를 다른 애그리거트에서 변경할 수 없다

- 애그리거트별 다른 구현 기술을 사용할 수 있다
- 예)
- 주문 애그리거트는 RDBMS에 저장하고
- 조회 성능이 중요한 상품 애그리거트는 NoSQL에 저장할 수 있다
- 각 도메인을 별도 프로세스로 서비스 하도록 구현할 수 있다

![아이디로 애그리거트를 참조하면 리포지터리마다 다른 저장소를 사용하여 확장성이 용이해 진다](https://user-images.githubusercontent.com/42866800/159904767-dbdeda5b-a2c7-4584-b9b3-e736ab113f23.png)
### ID를 이용한 참조와 조회 성능

- 참조하는 여러 애그리거트를 읽어야 할 때 조회 속도 문제가 발생할 수 있다
- 예)
- 주문 목록을 보여주기 위해 상품 애그리거트와 회원 애그리거트를 함께 읽어야 하는 경우
- 각 주문마다 상품과 회원 애그리거트를 읽어오는 경우
- 주문 개수가 10개인 경우 전체 주문을 읽어올때 한번
- 주문별로 상품을 읽어오기 위해 10번의 쿼리를 실행한다

- 조회 대상이 N일 때 N개를 읽어오는 한번의 쿼리와 연관된 데이터를 읽어오는 쿼리를 N번 실행하게 된다
- 따라서 N + 1 조회 문제가 발생한다
- 더 많은 쿼리를 실행하게 되어 전체 조회 속도가 느려진다
- 조인을 사용해야 한다
- ID 참조 방식을 객체 참조 방식으로 바꾸고 즉시 로딩을 사용하도록 해야 한다

- ID 참조 방식을 사용하면서 N + 1 조회 문제가 발생하지 않도록 하려면
- 데이터 조회를 위한 별도 DAO를 만들고 DAO의 조회 메서드에서 세타 조인을 사용하여 한번의 쿼리로 필요한 데이터를 로딩해야 한다
- 쿼리가 복잡하거나 SQL에 특화된 기능을 사용해야 한다면 조회를 위한 부분만 MyBatis 기술을 사용할 수 있다

### 애그리거트 마다 서로 다른 저장소를 사용하는 경우

- 한번의 쿼리로 관련 애그리거트를 조회할 수 없다
- 조회 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성해야 한다
- 코드가 복잡해지는 단점이 있지만 시스템의 처리량을 높일수 있는 장점이 있다

참고 - 

[https://ppiyo5.tistory.com/21](https://ppiyo5.tistory.com/21)

[https://hwannny.tistory.com/74](https://hwannny.tistory.com/74)