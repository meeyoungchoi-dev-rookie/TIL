## 시스템간 강결합의 문제

- 도메인 객체에 서비스를 전달하는 경우
- 외부 서비스 성능에 직접적으로 영향을 받게 된다

## 이벤트 개요

- 이벤트가 발생한다는 것은 상태가 변경됐다는 것을 의미한다
- 이벤트가 발생하면 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현한다
- 도메인 모델에서도 도메인의 상태 변경을 이벤트로 표현할 수 있다

### 이벤트 관련 구성요소

- 도메인 모델에서 이벤트 주체는 엔티티 , 밸류 , 도메인 서비스와 같은 도메인 객체이다
- 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생시킨다

- `이벤트 핸들러`
- 이벤트 생성 주체가 발생한 이벤트에 반응한다
- 이벤트 핸들러는 생성 주체가 발생한 이벤트를 전달받아 이벤트에 담긴 데이터를 사용하여 원하는 기능을 실행한다

- `이벤트 디스패처`
- 이벤트 생성 주체와 이벤트 핸들러를 연결해 주는것
- 이벤트 생성 주체가 이벤트를 생성하여 디스패처에 이벤트를 전달한다
- 이벤트를 전달받은 디스패처는 해당 이벤트를 처리하 ㄹ수 있는 해들러에 이벤트를 전파한다
- 이벤트 디스패처의 구현 방식에 따라 이벤트 생성과 처리를 동기나 비동기로 실행하게 된다

### 이벤트의 구성

- 이벤트는 발생한 이벤트에 대한 정보를 담는다
- `이벤트 종류` - 클래스 이름으로 이벤트 종류를 포현
- `이벤트 발생 시간`
- `추가 데이터` - 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보

- 이벤트는 이벤트 핸들러가 작업을 수행하는 데 필요한 최소한의 데이터를 담아야 한다
- 데이터가 부족할 경우 핸들러는 필요한 데이터를 읽기 위해 관련 API를 호출하거나 DB에서 데이터를 직접 읽어와야 한다
- 하지만 이벤트 자체와 관련 없는 데이터를 포함할 필요는 없다

### 이벤트 용도

- `트리거`
- 도메인의 상태가 바뀔때 다른 추러리를 해야 할 경우 후처리를 실행하기 위한 트리거로 이벤트를 사용한다
- 주문의 경우 주문 취소 이벤트가 트리거가 될 수 있다
- 주문을 취소하면 환불을 처리해야 하는데 이때 환불 처리를 위한 트리거로 주문 취소 이벤트를 사용할 수 있다
- `데이터 동기화`
- 배송지를 변경하면 외부 배송 서비스에 바뀐 배송지 정보를 전송해야 한다
- 주문 도메인은 배송지 변경 이벤트를 발생시키고 이벤트 핸들러는 외부 배송 서비스와 배송지 정보를 동기화 한다

### 이벤트 장점

- 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있다
- 기능 확장도 용이하다
- 기능을 확장해도 구매 도메인 로직은 수정할 필요가 없다


## 이벤트 , 핸들러, 디스패처 구현

### 이벤트 클래스

- 이벤트를 처리하는데 필요한 최소한의 데이터를 포함해야 한다
- 모든 이벤트가 공통으로 갖는 프로퍼티가 존재한다면 상위 클래스를 만들 수도 있다

### 이벤트 핸들러 인터페이스

- 이벤트 핸들러를 위한 상위 인터페이스
- EventHandler 인터페이스를 상속받는 클래스는 handle 메서드를 사용해서 필요한 기능을 구현하면 된다

### 이벤트 디스패처인 Events 구현

- 도메인을 사용하는 응용서비스는 이벤트를 받아 처리할 핸들러를 Events.handle() 로 등록한다
- 이벤트를 발생시킬 때는 Events.raise 메서드를 사용한다
- 이벤트를 처리할 핸들러를 찾아 handle 메서드를 실행한다

- Events는 핸들러 목록을 유지하기 위해 ThreadLocal 변수를 사용한다
- 톰캣과 같은 웹 애플리케이션 서버는 스레드를 재사용한다
- ThreadLocal에 보관한 값을 제거하지 않으면 기대했던 것과 다르게 코드가 동작할 수 있다
- 따라서 Events.reset 메서드를 실행해 줘야 한다

### AOP를 사용한 Events.reset 메서드 실행

- 응용 서비스가 끝나면 ThreadLocal에 등록된 핸들러 목록을 초기화 하기 위해 reset 매서드를 실행한다
- 모든 응용서비스마다 Events.reset 메서드를 넣는 것은 중복에 해당한다
- 중복을 없애기 위해 적합한 것이 AOP이다
- @Service가 붙는 클래스는 Events.reset 메서드를 명시적으로 호출하지 않아도 된다
- @Service를 사용하지 않을 경우 @Around의 포인트 컷에 execution 명시지를 사용해야 한다


## 비동기 이벤트 처리

- A하면 이어서 B하라
- A하면 일정 시간 안에 B하라
- A 이벤트가 발생하면 별도 스레드로 B를 수행하는 핸들러를 실행하는 방식

### 이벤트를 비동기로 구현할 수 있는 방법

- 로컬 핸들러를 비동기로 실행하기
- 메시지 큐를 사용하기
- 이벤트 저장소와 이벤트 포워더 사용하기
- 이벤트 저장소와 이벤트 제공 API 사용하기

### 로컬 핸들러의 비동기 실행

- 비동기로 실행할 이벤트 핸들러는 execute.submit 메서드를 사용하여 스레드 풀에 핸들러 실행 작업을 등록한다
- executor는 내부적으로 사용하는 스레드 풀을 사용하여 인자로 전달받은 람다식을 실행한다
- 따라서 raise 메서드를 실행하는 스레드가 아닌 다른 스레드를 사용하여 이벤트 핸들러를 비동기로 실행한다
- 별도 스레드로 이벤트 핸들러를 사용하면 raise 메서드와 관련된 트랜잭션 범위에 이벤트 핸들러 실행이 묶이지 않는다
- 따라서 한 트랜잭션으로 실행해야 하는 이벤트 핸들러는 비동기로 처리해서는 안된다

```java
executor.submit( () -> handler.handle(event));
```

- 동기로 실행할 이벤트 핸들러는 바로 실행한다

### 메시징 시스템을 이용한 비동기 구현

- RabbitMQ 같은 메시징 큐를 사용하는 것
- 이벤트가 발생하면 이벤트 디스패처는 이벤트를 메시지 큐에 보낸다
- 메시지 큐는 이벤트를 메시지 리스너에 전달한다
- 메시지 리스너는 알맞은 이벤트 핸들러를 사용하여 이벤트를 처리한다
- 메시지 큐에서 이벤트를 읽어와 처리하는 과정은 별도 스레드나 프로세스로 처리된다
- 이벤트를 발생하는 주체와 이벤트 핸들러가 별도 프로세스에서 동작한다

### 이벤트 저장소를 이용한 비동기 처리

- 이벤트를  DB에 저장한 뒤에 별도 프로그램을 사용하여 이벤트 핸들러에 전달한다
- 이벤트가 발생하면 핸들러는 스토리지에 이벤트를 저장한다
- 포워더는 주기적으로 이벤트 저장소에서 이벤트를 가져와 이벤트 핸들러를 실행한다
- 포워더는 별도 스레드를 사용하기 때문에 이벤트 발생과 처리가 비동기로 처리된다
- 도메인의 상태와 이벤트 저장소로 동일한 DB를 사용한다
- 도메인의 상태 변화와 이벤트저장이 로컬 트랜잭션으로 처리된다
- 이벤트를 물리적 저장소에 보관한다
- 핸들러가 이벤트 처리에 실패할 경우 포워더는 다시 이벤트 저장소에서 이벤트를 읽어와 핸들러를 실행하면 된다

- 이벤트를 외부 API에 제공하는 방식
- API 방식과 포워더 방식의 차이점은 이벤트를 전달하는 방식에 있다
- 외부 핸들러가 API 서벌르 통해 이벤트 목록을 가져온다
- 이벤트 목록을 요구하는 외부 핸들러가 자신이 어디까지 이벤트를 처리했는지 거억해야 한다

### 이벤트 저장소 구현

- 이벤트를 저장할 저장소가 필요하다
- `EventEntry` - 이벤트 저장소에 보관할 데이터
- `EventStore` - 이벤트를 저장하고 조회하는 인터페이스를 제공한다
- `JdbcEventStore` - JDBC를 사용한 EventStore 구현 클래스이다
- `EventApi` - REST API를 사용하여 이벤트 목록을 제공하는 컨트롤러

### 이벤트 저장을 위한 이벤트 핸들러 구현

- 이벤트를 이벤트 저장소에 추가하는 이벤트 핸들러를 구현
- EventStoreHandler의 handle 메서드는 evetnStore 객체의 store 메서드를 사용하여 이벤트 객체를 저장한다
- 이벤트 타입에 상관없이 이벤트는 저장소에 보관된다

### REST API 구현

- EventAPI 가 처리하는 URL에 연결하면 JSON 형식으로 EventEntry 목록을 구할 수 있다
- 이벤트를 수정하는 기능이 없으므로 REST API 도  단순 조회 기능만 제공한다
1. 가장 마지막에 처리한 데이터의 오프셋인 lastOffset을 구한다
2. 저장한 lastOffset이 없으면 0을 사용한다
3. 마지막에 처리한 lastOffset을 offset으로 사용해서 API를 실행한다
4. API 결과로 받은 데이터를 처리한다
5. offset + 데이터 개수를 lastOffset으로 저장한다

### 포워더 구현

- 일정 주기로 EvetnStotre로 부터 이벤트를 읽어 이벤트 핸들러에 전달한다
- API 방식에서 클라이언트와 마찬가지로 마지막으로 전달한 이벤트의 오프셋을 기억해 뒀다가 다음 시점에 마지막으로 처리한 오프셋부터 이벤트를 가져오면 된다

### 이벤트 적용 시 고려사항

- 포워더에서 전송 실패를 얼마나 허용할 것인가
- 이벤트 손실
- 이벤트 순서
- 이벤트 재처리