## JPA는 영속성 컨텍스트를 가지고 있다

### 영속성

- 데이터를 영구적으로 저장하게 해주는 것
- 데이터베이스에 영구적으로 저장한다

### 컨텍스트

- 어떤 대상에 대한 모든 정보를 갖고 있는 것

### 영속성 컨텍스트

- 자바 객체 (엔티티)를 영구 저장하는 환경
- 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 역할을 한다
- 엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다
- 왜 필요한가?
    - 엔티티의 동일성 보장
    - 엔티티가 수정 되었을때 데이터 변경을 감지한다
        - 데이터베이스와 OOP의 불일치를 해결해 준다
    - 엔티티 매니저가 자바의 엔티티와 데이터베이스의 스냅샷을 비교하여 변경된 엔티티를 차즌다
    - 변경된 엔티티가 있으면 UPDATE 쿼리를 생성하여 데이터베이스에 저장한다
    - 데이터베이스 트랜잭션을 커밋한다
    

`team`

| ID | Name | Year |
| --- | --- | --- |
| 1 | 롯데 | 1990 |
| 2 | NC | 2005 |

`player`

| ID | Name | teamId |
| --- | --- | --- |
| 1 | 이대호 | 1 |
| 2 | 공필성 | 1 |
| 3 | 가득영 | 1 |
| 4 | 홍길동 | 2 |

- 데이터베이스는 기본자료형 타입의 데이터만 가질수 있다
- Object 타입의 데이터는 가질 수 없다

`자바의 관점`

```java
class Team {
	int id;
  String name;
  String year;
}
```

```java
class Player {
	int id;
  String name;
  int teamId;
}
```

- 데이터베이스에서 id가 2인 데이터를 select 한 경우

```java
id: 2 , name : "공필성" , teamId : 1
```

- 해당 데이터만 보고 공필성 이라는 사람이 어떤 팀에 속해 있는지 알 수 없다
- teamId 변수를 사용하여 다시 team 테이블에서 팀에 대한 정보를 select 해야 한다
- 혹은 team 테이블과 player 테이블을 조인하여 해결해야 한다

`하지만 자바는 기본 자료형이 아닌 Object를 저장할 수 있다`

```java
class Player {

	int id;
  String name;
  Team team;
}
```

- Player 클래스를 위 처럼 설계하게 되면 데이터베이스의 player 테이블과 자바의 클래스가 모순이 된다
- 왜냐하면 데이터베이스에는 Object를 저장할 수 없기 때문이다
- ORM의 장점
    - Team 타입의 객체를 저장할 수 있다
    - 진정한 객체지향 프로그램이 가능하다
    - 즉 , 자바 객체가 주도권을 갖고 있는 모델을 만들수 있다
    - OOP기반으로 모델링 하면 JPA가 자동으로 Player 와 Team Object의 관계를 파악하여 쿼리를 만들어서 데이터베이스에 데이터를 넣어준다
        - 즉 , JPA가 자동으로 FK를 집어넣어준다
    - ORM을 통해 데이터베이스와 OOP의 불일치를 해결할 수 있다

