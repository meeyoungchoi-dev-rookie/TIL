### **ComponentScan 등장 배경**

- xml 설정파일에서 모든 빈을 일일이 등록해야 하는 것은 매우 번거롭다

### **빈으로 등록되려면 자바 파일이 메모리에 띄워야 한다**

- new 를 하여 메모리에 띄워야 한다
- spring에는 IoC 기능이 있어 개발자가 직접 new 할 필요가 없다
- DispatcherServlet이 컴포넌트 스캔을 통해서 new 를 해준다
- src 폴더 밑에 있는 모든 파일에 대해 컴포넌트 스캔을 해준다
- spring이 어노테이션 기법으로 어떤 파일을 new 해야 하는지 정해 놨다

```java
@Controller
@RestController
@Configuration
@Service
@Repository
@Component
```

### **ComponentScan**

- 빈으로 등록 될 준비를 마친 클래스들을 스캔하여 빈으로 등록해 주는 것
- 자바 파일에서 @Component 어노테이션 및 streotype(@Servie , @Repository, @Controller) 어노테이션이 부여된 Class들을
- 찾아 자동으로 스캔하여 Bean 으로 등록해주는 역할을 한다

### **ContextLoaderListener 등장 배경**

- 서블릿이 만들어지면 스레드가 생성된다
- 요청을 보낸 사람이 100인데 스레드를 20개를 만들기로 설정했다면
- 20개의 스레드가 만들어 진다
- 각 스레드는 서로 독립적이다
- 모든 요청에 대해 공통으로 사용하는 것들이 있다
- 예) 데이터베이스 커넥션
- 데이터베이스 와 관련된 것 또는 모든 객체들이 공통으로 사용하는 것은 ContextLoaderListener를 통해 미리 띄워놓는다
- ContenxtLoaderListener는 root_ApplicationContext 파일을 읽는다
- 스레드 마다 공통적으로 사용하는 애들을 bean으로 만들어 메모리에 띄워 준다
- 이들도 spring IoC 컨테이너에서 관리 해준다

## **스프링 컨테이너**

- DispatcherServlet에 의해 생성되어지는 객체들은 어디에서 관리될까?

### ApplicationContext

- 애플리케이션에 등록 된 빈에 대한 구성정보를 제공하는 인터페이스
- `servlet-applicationContext` : 웹 과 관련된 어노테이션만 스캔하여 메모리에 띄운다
    - Controller , ViewResolver , HandlerMapping
- `root-applicaion` : Service , Repository 어노테이션을 스캔하고 DB 관련 객체를 생성한다
    - 모든 스레드들이 공유해서 사용한다
- root-applicationContext는 servlet-applicationContext 보다 먼저 로드 된다
- servlet-applicationContext에서는 root-applicationContext가 로드된 객체를 참조할 수 있다
- 우리는 객체의 주소를 몰라도 된다
- 왜? 필요할 때 DI 하면 되기 때문이다

### BeanFactory

- @Bean 어노테이션을 사용하여 필요한 객체를 BeanFactory에 등록한다
- 초기에 메모리에 로드되지 않고 필요할 때 getBean() 이라는 메소드를 호출하여 메모리에 로드한다
- 즉 , 클래스에서 해당 메소드를 누군가가 필요로 하여 사용하고자 할때
- 호출하여 로드하기 때문에 lazy-loading이다

```java

@Configuration
class A {

  @Bean
	객체 메소드() {
		return new 객체();
	}

}
```