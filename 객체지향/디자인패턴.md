## Singleton 패턴
+ 객체를 각각 생성하지 않고 객체를 딱 하나만 생성하여 메모리 용량을 딱 하나만 사용하게 된다

+ 왜?
+ 생성자를 static으로 선언해 두면 이미 메모리에 공간을 차지하고 있기 때문에 어디에서 객체를 생성해도 동일한 객체를 사용하게 된다


+ 하지만 멀티쓰레드 환경에서 에러가 발생할수 있기 때문에 싱글톤을 안전하게 사용할 수 있는 방법에 대해 알아야 한다

## Strategy 패턴
+ 기능을 모듈 하나하나로 분리하여 역할에 따라서 모듈을 그때그때 갈아끼우는 방식
+ 옵션들 마다 행동을 모듈화 하여 독립적이고 상호 교체 가능하게 만든다


## State 패턴
+ 코드내의 조건문들을 대체하려는 목적으로 사용된다
+ 객체가 특정 상태에 따라 행위를 달리하는 경우 객체 자체가 직접 상태를 체크하여 행위를 호출하지 않고
+ 상태를 객체화 하여 상태가 행동을 할 수 있도록 위임한다
+ 메서드 내부에 조건문이 많아지면 상태에 따라 하고자 하는 행위를 파악하기가 쉽지 않다
+ 또한 기능이 변경될 때 마다 일일이 다 찾아가며 조건문을 수정해야 한다
+ 객체의 상태를 클래스로 선언하고 클래스에서 해당 상태에서 할 수 있는 행위를 메서드로 정의한다
+ 각 상태 클래스를 인터페이스로 캡슐화 하여 클라이언트에서 인터페이스를 호출한다 

## Command 패턴
+ 객체의 메서드를 클래스로 만들어 캡슐화 한다
+ 객체간 의존성을 제거하기 위해 사용한다
+ 시스템 확장성이 높아지고 유연해 진다

## Adapter 패턴
+ Adapter : 형식이 다른 둘 사이에 연결되서 이 둘이 호환될 수 있도록 해주는 도구
+ 인터페이스가 서로 다른 객체들이 같은 형식 아래에서 작동할 수 있도록 한다

## Proxy 패턴
+ 대리인 역할을 하는 클래스를 따로 두고 사용하는 것
+ 즉 , 필요할 때만 실제 객체를 생성하여 사용한다
+ 효율적이고 유연한 프로그램이 가능해 진다


### 참고
https://victorydntmd.tistory.com/294
https://victorydntmd.tistory.com/295